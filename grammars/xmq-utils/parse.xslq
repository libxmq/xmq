xsl:stylesheet(version   = 1.0
               xmlns:xsl = http://www.w3.org/1999/XSL/Transform)
{
    xsl:output(method         = html
               doctype-system = about:legacy-compat)

    xsl:key(name  = "trakey"
            match = "parse/tra"
            use   = id)
    xsl:key(name  = "blokey"
            match = "parse/block"
            use   = id)
    xsl:template(match = /)
    {
        html {
            head {
                style = 'body {}
                         * { font-family: monospace, Consolar, DejaVu Sans Mono, Lucida Console, Courier, "Courier New"; }
                         table { border-collapse: collapse; }
                         h1   {color: blue;}
                         p    {color: red;}
                         table, th, td { border: 1px solid; text-align: center; }
                         td, th { min-width: 2em; min-height: 1em; white-space: nowrap; }
                         .rule { background-color: cyan; padding-right: 1em; padding-left: 1em; position: sticky; right: 0px;
                                 max-width: 20vw; white-space: wrap; }
                         .top { background-color: cyan; font-weight: bold; position: sticky; top: 0px;}
                         .step { background-image: linear-gradient(45deg, #3bc420 41.67%, #e33030 41.67%, #e33030 50%, #3bc420 50%, #3bc420 91.67%, #e33030 91.67%, #e33030 100%); background-size: 16.97px 16.97px; }
                         .step[used="true"] { color: black; background: solid; background: lightgreen; }
                         .dot[blocked="true"] { color: red; background: solid; background: orange; }
                         .pred { background-color: lightyellow; }
                         .notlookahead { text-color: white; background-color: purple; }
                         .dot { background-color: orange; }
                         .eof { background-color: lightgrey; min-width: 1ch; width: 1ch; }
                         .predotted { color: black; background-color: orange;}
                         .dotted { color: darkorange;}
                         .info { text-align: left; background: lightyellow; font-size: 0.5em; }
                         .dotted[blocked="true"] { color: white; background: red; }
                         .completed { color: black; background-color: lightgreen; }
                         .predicted { color: black; background-color: lightyellow; }'
            }
            body {
                table {
                    tr {
                        xsl:for-each(select = parse/scan)
                        {
                            xsl:variable(name   = content
                                         select = char)
                            th
                            {
                                xsl:attribute(name="class") {
                                    xsl:choose {
                                        xsl:when(test = "$content = 'ω'") = 'top eof'
                                        xsl:otherwise = top
                                    }
                                }
                                xsl:value-of(select = char)
                            }
                        }
                        th(class = rule)
                        {
                        }
                    }
                    xsl:apply-templates(match = parse/step)
                }
            }
        }
    }
    xsl:template(match = scan)
    xsl:template(match = block)
    // sl:template(match = 'step[(position() <=2) or (position() >= last()-1)]')
    // [(position() > 2) and (position() < last()-1)]
    xsl:template(match = tra)
    xsl:template(match = step)
    {
        xsl:variable(name   = id
                     select = id)
        xsl:variable(name   = from
                     select = from)
        xsl:variable(name   = to
                     select = to)
        xsl:variable(name   = total
                     select = total)
        xsl:variable(name   = pre
                     select = 'number($from)')
        xsl:variable(name   = mid
                     select = 'number($to)-number($from)')
        xsl:variable(name   = post
                     select = 'number($total)-number($to)-1')
        xsl:variable(name = final)
        {
            xsl:choose {
                xsl:when(test= "$total = $to")
                {
                    '0'
                }
                xsl:otherwise = '1'
            }
         }

        tr {
/*            td {
                't=' xsl:value-of(select = '$total') ' '
                'fr =' xsl:value-of(select = '$from') ' '
                'to =' xsl:value-of(select = '$to') ' '
                'p=' xsl:value-of(select = '$pre') ' '
                'm=' xsl:value-of(select = '$mid') ' '
                'ps=' xsl:value-of(select = '$post') ' '
                'fi=' xsl:value-of(select = '$final') ' '
            }*/
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = ''
                xsl:with-param(name = count) {
                    xsl:value-of(select = '$pre')
                }
            }
            td(colspan = '{$mid}')
            {
                xsl:attribute(name="class") {
                    xsl:choose {
                        xsl:when(test = "type = 'complete'") = step
                        xsl:when(test = "type = 'prediction'") = pred
                        xsl:when(test = "type = 'not'") = notlookahead
                        xsl:otherwise = dot
                    }
                }
                xsl:attribute(name="used") {
                    xsl:for-each(select = "key('trakey',$id)") {
                        xsl:if(test = "position()=1") = true
                    }
                }
                xsl:attribute(name="blocked") {
                    xsl:for-each(select = "key('blokey',$id)") {
                        xsl:if(test = "position()=1") = true
                    }
                }
                xsl:choose {
                    xsl:when(test = "type = 'not'") = ' '
                    xsl:otherwise {
                        xsl:apply-templates(select = name)
                    }
                }
            }
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = ''
                xsl:with-param(name = count) {
                    xsl:value-of(select = '$post')
                }
            }
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = 'eof'
                xsl:with-param(name = count) {
                    xsl:value-of(select = '$final')
                }
            }
            td(class = rule) {
                xsl:apply-templates(select = name)
                xsl:apply-templates(select = cost)
                ' → '
                span(class = completed) {
                    xsl:apply-templates(select = body)
                }
                span(class = dotted) {
                    xsl:attribute(name="blocked") {
                        xsl:for-each(select = "key('blokey',$id)") {
                            xsl:if(test = "position()=1") = true
                        }
                    }
                    xsl:apply-templates(select = dot)
                    xsl:for-each(select = "key('blokey',$id)") {
                        '*'
                        xsl:value-of(select = btype)
                    }
                }
            }
            td(class = info) {
               '('
               xsl:value-of(select = id)
               ') '
               xsl:value-of(select = info)
               ':'
               xsl:value-of(select = iinfo)
            }
        }
    }
    // The gencols macro repeats empty td columns exactly count times.
    xsl:template(name = gencols)
    {
        xsl:param(name = class)
        xsl:param(name = count)
        xsl:if(test = '$count > 0')
        {
            td(class = '{$class}')
        }
        xsl:if(test = '$count > 0')
        {
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = i)
                {
                    xsl:value-of(select = '$class')
                }
                xsl:with-param(name = count)
                {
                    xsl:value-of(select = '$count - 1')
                }
            }
        }
    }
}
