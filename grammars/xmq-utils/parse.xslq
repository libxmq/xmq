xsl:stylesheet(version   = 1.0
               xmlns:xsl = http://www.w3.org/1999/XSL/Transform)
{
    xsl:output(method         = html
               doctype-system = about:legacy-compat)
    xsl:param(name = level)
    xsl:key(name  = trakey
            match = parse/ixml-bt-step
            use   = dr)
    xsl:key(name  = blokey
            match = parse/block
            use   = id)
    xsl:variable(name   = num_tokens
                 select = /parse/ixml-pa-step[1]/n)
    xsl:variable(name   = num_steps
                 select = 'count(/parse/ixml-pa-step)')
    xsl:template(match = /)
    {
        html {
            head {
                style = 'body {}
                         * { font-family: monospace, Consolar, DejaVu Sans Mono, Lucida Console, Courier, "Courier New"; }
                         table { border-collapse: collapse; }
                         h1   {color: blue;}
                         p    {color: red;}
                         a { cursor: pointer; }
                         #grammar { display: none; }
                         td.grammar { border: 1px solid; text-align: left; background-color: #aaa; }
                         td.lookahead { border: 1px solid; text-align: left; background-color: yellow; }
                         table.steps, th, td { border: 1px solid; text-align: center; }
                         td, th { min-width: 2em; min-height: 1em; white-space: nowrap; }
                         .rule { text-align: left; background-color: cyan; padding-right: 1em; padding-left: 1em; position: sticky; right: 0px;
                                 max-width: 30vw; white-space: wrap; }
                         .rulebox { flex-wrap: wrap; flex-direction: row; display: flex; justify-content: space-between; }
                         span.rulecontent { }
                         span.ruleid { font-size: 0.5em; }
                         .top { background-color: cyan; font-weight: bold; position: sticky; top: 0px;}
                         .step { background-image: linear-gradient(45deg, #3bc420 41.67%, #e33030 41.67%, #e33030 50%, #3bc420 50%, #3bc420 91.67%, #e33030 91.67%, #e33030 100%); background-size: 16.97px 16.97px; }
                         .step[used="true"] { color: black; background: solid; background: lightgreen; }
                         .dot[blocked="true"] { color: red; background: solid; background: orange; }
                         .pred { background-color: lightyellow; }
                         .notlookahead { text-color: white; background-color: purple; }
                         .dot { background-color: orange; }
                         .eof { background-color: lightgrey; min-width: 1ch; width: 1ch; }
                         .predotted { color: black; background-color: orange;}
                         .dotted { color: darkorange;}
                         .info { text-align: left; background: lightyellow; font-size: 0.5em; }
                         .leinfo { text-align: left; font-size: 0.5em; background-color: cyan; padding-right: 1em; padding-left: 1em; position: sticky; right: 0px; max-width: 30vw; white-space: wrap; }

                         .dotted[blocked="true"] { color: white; background: red; }
                         .completed { color: black; background-color: lightgreen; }
                         .predicted { color: black; background-color: lightyellow; }'
                script = "function toggle(name) { const e = document.getElementById(name);
                                                  if (e.style.display === 'none' || e.style.display === '')
                                                       e.style.display = 'table';
                                                  else e.style.display = 'none';  }"
            }
            body {
                a(onclick = "toggle('grammar'); return false;") = '⊞ Grammar'
                table(id = grammar)
                {
                    xsl:apply-templates(select = parse/ixml-gr)
                    xsl:apply-templates(select = parse/ixml-nt)
                }
                table(class = steps) {
                    tr {
                        xsl:for-each(select = parse/ixml-pa-token)
                        {
                            xsl:variable(name   = content
                                         select = char)
                            th {
                                xsl:attribute(name = class)
                                {
                                    xsl:choose {
                                        xsl:when(test = "$content = 'ω'") = 'top eof'
                                        xsl:otherwise = top
                                    }
                                }
                                xsl:value-of(select = $content)
                            }
                        }
                        th(class = rule)
                    }
                    xsl:apply-templates(select = ixml-pa-token|parse/ixml-pa-info|parse/ixml-bt-step|parse/ixml-bt-info|parse/ixml-pa-step)
                }
            }
        }
    }
    xsl:template(match = parse/ixml-gr)
    {
        tr {
            td(class = grammar)
            {
                xsl:value-of(select = .)
            }
        }
     }
     xsl:template(match = parse/ixml-nt)
     {
         tr {
             td(class = lookahead)
             {
                 xsl:value-of(select = .)
             }
         }
     }

    xsl:template(match = parse/ixml-pa-token)
    xsl:template(match = parse/ixml-pa-info)
    {
        tr {
            td {
                xsl:attribute(name = colspan)
                {
                    xsl:value-of(select = $num_tokens)
                }
            }
            td(class = leinfo)
            {
                xsl:value-of(select = info)
            }
        }
    }
    xsl:template(match = parse/ixml-bt-step)
    {
        xsl:choose {
            xsl:when(test = "$level = 'trace'")
            {
        tr {
            td {
                xsl:attribute(name = colspan)
                {
                    xsl:value-of(select = $num_tokens)
                }
            }
            td(class = leinfo)
            {
                'adding (d'
                xsl:value-of(select = dr/id)
                ','
                xsl:value-of(select = dr/from)
                '-'
                xsl:value-of(select = dr/to)
                ')'
            }
        }
            }
            xsl:otherwise
        }
    }
    xsl:template(match = parse/ixml-bt-info)
    {
        tr {
            td {
                xsl:attribute(name = colspan)
                {
                    xsl:value-of(select = $num_tokens)
                }
            }
            td(class = leinfo)
            {
                xsl:value-of(select = info)
            }
        }
    }
    xsl:template(match = parse/ixml-pa-step)
    {
        xsl:variable(name   = id
                     select = dr/id)
        xsl:variable(name   = from
                     select = dr/from)
        xsl:variable(name   = too
                     select = dr/to)
        xsl:variable(name = to)
        {
            xsl:choose {
                xsl:when(test = '$too = $from') {
                    xsl:value-of(select = $from+1)
                }
                xsl:otherwise {
                    xsl:value-of(select = $too)
                }
            }
        }
        xsl:variable(name   = total
                     select = n)
        xsl:variable(name   = pre
                     select = 'number($from)')
        xsl:variable(name   = mid
                     select = 'number($to)-number($from)')
        xsl:variable(name   = post
                     select = 'number($total)-number($to)-1')
        xsl:variable(name = final)
        {
            xsl:choose {
                xsl:when(test = '$total = $to') = 0
                xsl:otherwise = 1
            }
        }
        tr {
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = ''
                xsl:with-param(name = count)
                {
                    xsl:value-of(select = $pre)
                }
            }
            td(colspan = '{$mid}')
            {
                xsl:attribute(name = class)
                {
                    xsl:choose {
                        xsl:when(test = "type = 'full'") = step
                        xsl:when(test = "type = 'none'") = pred
                        xsl:when(test = "type = 'not'") = notlookahead
                        xsl:otherwise = dot
                    }
                }
                xsl:attribute(name = used)
                {
                    xsl:for-each(select = '''key('trakey',dr)''')
                    {
                        xsl:if(test = 'position()=1') = true
                    }
                }
                xsl:attribute(name = blocked)
                {
                    xsl:for-each(select = '''key('blokey',$id)''')
                    {
                        xsl:if(test = 'position()=1') = true
                    }
                }
                xsl:choose {
                    xsl:when(test = "type = 'not'") = ' '
                    xsl:otherwise {
                        xsl:apply-templates(select = rule/name)
                    }
                }
            }
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = ''
                xsl:with-param(name = count)
                {
                    xsl:value-of(select = $post)
                }
            }
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = class) = eof
                xsl:with-param(name = count)
                {
                    xsl:value-of(select = $final)
                }
            }
            td(class = rule)
            {
                div(class = rulebox)
                {
                    span(class = rulecontent)
                    {
                        xsl:apply-templates(select = rule/name)
                        xsl:apply-templates(select = cost)
                        xsl:choose {
                            xsl:when(test = "type = 'not'") = ''
                            xsl:otherwise {
                                ' → '
                                span(class = completed)
                                {
                                    xsl:apply-templates(select = rule/body)
                                }
                                span(class = dotted)
                                {
                                    xsl:attribute(name = blocked)
                                    {
                                        xsl:for-each(select = "key('blokey',$id)")
                                        {
                                            xsl:if(test = 'position()=1') = true
                                        }
                                    }
                                }
                                xsl:apply-templates(select = rule/dot_body)
                                xsl:for-each(select = "key('blokey',$id)")
                                {
                                    '*'
                                    xsl:value-of(select = btype)
                                }
                            }
                        }
                    }
                    span(class = ruleid)
                    {
                        '(d'
                        xsl:value-of(select = dr/id)
                        ','
                        xsl:value-of(select = dr/from)
                        '-'
                        xsl:value-of(select = dr/to)
                        ') '
                    }
                }
            }
        }
    }
    // The gencols macro repeats empty td columns exactly count times.
    xsl:template(name = gencols)
    {
        xsl:param(name = class)
        xsl:param(name = count)
        xsl:if(test = '$count > 0')
        {
            td(class = '{$class}')
        }
        xsl:if(test = '$count > 0')
        {
            xsl:call-template(name = gencols)
            {
                xsl:with-param(name = i)
                {
                    xsl:value-of(select = $class)
                }
                xsl:with-param(name = count)
                {
                    xsl:value-of(select = '$count - 1')
                }
            }
        }
    }
}
